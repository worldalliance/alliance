import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { ActionsService } from 'src/actions/actions.service';
import { ActionTaskType } from 'src/actions/entities/action.entity';
import { UserService } from 'src/user/user.service';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import Stripe from 'stripe';
import { PaymentUserDataToken } from './entities/payment-token.entity';
import { MailService } from 'src/mail/mail.service';
@Injectable()
export class PaymentsService {
  private readonly stripe: Stripe;

  constructor(
    private userService: UserService,
    private actionService: ActionsService,
    private mailService: MailService,
    @InjectRepository(PaymentUserDataToken)
    private paymentUserDataTokenRepository: Repository<PaymentUserDataToken>,
  ) {
    if (!process.env.STRIPE_API_KEY) {
      throw new Error('STRIPE_API_KEY must be set');
    }
    this.stripe = new Stripe(process.env.STRIPE_API_KEY, {
      apiVersion: '2025-03-31.basil',
    });
  }

  async getOrCreateCustomer(userId: number, email?: string): Promise<string> {
    const user = await this.userService.findOne(userId);
    if (!user) {
      throw new NotFoundException(`User ${userId} not found`);
    }

    if (user.stripeCustomerId) {
      return user.stripeCustomerId;
    }

    const customer = await this.stripe.customers.create({
      metadata: { userId: String(userId) },
      email: email ?? user.email ?? undefined,
    });

    user.stripeCustomerId = customer.id;
    await this.userService.update(userId, user);

    return customer.id;
  }

  async createPaymentUserDataToken(): Promise<string> {
    let token = await this.paymentUserDataTokenRepository.create();
    token = await this.paymentUserDataTokenRepository.save(token);
    return token.id; //autogenerated uuid
  }

  async updatePaymentUserDataToken(
    tokenId: string,
    data: Partial<PaymentUserDataToken>,
  ): Promise<void> {
    await this.paymentUserDataTokenRepository.update(tokenId, data);
  }

  async handleSuccessfulPayment(pi: Stripe.PaymentIntent): Promise<void> {
    let userId: number;

    if (pi.customer) {
      const customerId = pi.customer as string;
      // Authenticated user payment
      const user = await this.userService.findOneByStripeCustomerId(customerId);
      if (!user) {
        throw new NotFoundException(
          `User with stripeCustomerId ${customerId} not found`,
        );
      }
      userId = user.id;
      console.log('got authenticated user with id', user.id);
    } else {
      const userToken = pi.metadata.token;
      if (!userToken) {
        throw new Error('No token in payment intent metadata');
      }

      console.log('userToken from payment intent metadata', userToken);

      const userTokenEntity = await this.paymentUserDataTokenRepository.findOne(
        {
          where: { id: userToken },
        },
      );
      if (!userTokenEntity) {
        throw new NotFoundException(
          `Payment user data token ${userToken} not found`,
        );
      }
      const firstName = userTokenEntity.firstName;
      const lastName = userTokenEntity.lastName;
      const email = userTokenEntity.email;

      const user = await this.userService.createPartialProfile({
        firstName,
        lastName,
        email,
      });
      const token = await this.userService.generatePasswordResetToken(user.id);
      this.mailService.sendPartialSignupEmail(email, firstName, token);

      const customer = await this.stripe.customers.create({
        metadata: { userId: String(user.id) },
        email: email,
      });
      await this.stripe.paymentIntents.update(pi.id, {
        customer: customer.id,
      });
      await this.userService.setStripeCustomerId(user.id, customer.id);
      userId = user.id;
    }

    if (pi.metadata.actionId) {
      const actionId = parseInt(pi.metadata.actionId);

      console.log('actionId: ', actionId);

      if (
        (await this.actionService.findOne(actionId)).type !==
        ActionTaskType.Funding
      ) {
        throw new InternalServerErrorException(
          "Getting a payment event for a non-funding action shouldn't ever happen",
        );
      }
      await this.actionService.completeAction(actionId, userId);
      console.log('completed action');
    } else {
      throw new Error('No actionId in payment intent metadata');
    }
  }
}
